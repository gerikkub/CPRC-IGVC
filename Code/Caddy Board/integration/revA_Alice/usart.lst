   1               		.file	"usart.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 106               		.comm USART_WriteQueue,2,1
 107               		.comm USART_ReadQueue,2,1
 108               		.comm USART_WriteQueueLog,2,1
 112               	.global	USART_Init
 114               	USART_Init:
 115               		.stabd	46,0,0
   1:usart.c       **** /***************************
   2:usart.c       **** *
   3:usart.c       **** * Filename: usart.cpp
   4:usart.c       **** *
   5:usart.c       **** * Description: Provides print methods for various
   6:usart.c       **** *  datatypes using USART.
   7:usart.c       **** *
   8:usart.c       **** * Authors: Doug Gallatin and Jason Schray
   9:usart.c       **** * Edited by: Tim Peters & James Humphrey
  10:usart.c       **** *
  11:usart.c       **** ***************************/
  12:usart.c       **** 
  13:usart.c       **** #include "FreeRTOS.h"
  14:usart.c       **** #include "semphr.h" 
  15:usart.c       **** #include "queue.h"
  16:usart.c       **** #include "protocol.h"
  17:usart.c       **** 
  18:usart.c       **** #include <stdlib.h>
  19:usart.c       **** #include <stdint.h>
  20:usart.c       **** #include <avr/io.h>
  21:usart.c       **** #include <avr/interrupt.h>
  22:usart.c       **** 
  23:usart.c       **** 
  24:usart.c       **** #include "usart.h"
  25:usart.c       **** 
  26:usart.c       **** xQueueHandle USART_WriteQueue;
  27:usart.c       **** xQueueHandle USART_ReadQueue;
  28:usart.c       **** xQueueHandle USART_WriteQueueLog;
  29:usart.c       **** 
  30:usart.c       **** 
  31:usart.c       **** 
  32:usart.c       **** /************************************
  33:usart.c       **** * Procedure: usart_init
  34:usart.c       **** *  
  35:usart.c       **** * Description: Initializes the USART module with 
  36:usart.c       **** *  the specified baud rate and clk speed.
  37:usart.c       **** *
  38:usart.c       **** * Param buadin: The desired Baud rate.
  39:usart.c       **** * Param clk_seedin: The clk speed of the ATmega328p
  40:usart.c       **** ************************************/
  41:usart.c       **** void USART_Init(uint16_t baudin, uint32_t clk_speedin) {
 117               	.LM0:
 118               	.LFBB1:
 119 0000 DF93      		push r29
 120 0002 CF93      		push r28
 121 0004 CDB7      		in r28,__SP_L__
 122 0006 DEB7      		in r29,__SP_H__
 123 0008 2A97      		sbiw r28,10
 124 000a 0FB6      		in __tmp_reg__,__SREG__
 125 000c F894      		cli
 126 000e DEBF      		out __SP_H__,r29
 127 0010 0FBE      		out __SREG__,__tmp_reg__
 128 0012 CDBF      		out __SP_L__,r28
 129               	/* prologue: function */
 130               	/* frame size = 10 */
 131               	/* stack size = 12 */
 132               	.L__stack_usage = 12
 133 0014 9E83      		std Y+6,r25
 134 0016 8D83      		std Y+5,r24
 135 0018 4F83      		std Y+7,r20
 136 001a 5887      		std Y+8,r21
 137 001c 6987      		std Y+9,r22
 138 001e 7A87      		std Y+10,r23
  42:usart.c       ****     USART_WriteQueue = xQueueCreate(64,sizeof(uint8_t));
 140               	.LM1:
 141 0020 80E4      		ldi r24,lo8(64)
 142 0022 61E0      		ldi r22,lo8(1)
 143 0024 40E0      		ldi r20,lo8(0)
 144 0026 0E94 0000 		call xQueueGenericCreate
 145 002a 9093 0000 		sts USART_WriteQueue+1,r25
 146 002e 8093 0000 		sts USART_WriteQueue,r24
  43:usart.c       ****     USART_ReadQueue = xQueueCreate(8,sizeof(uint8_t));
 148               	.LM2:
 149 0032 88E0      		ldi r24,lo8(8)
 150 0034 61E0      		ldi r22,lo8(1)
 151 0036 40E0      		ldi r20,lo8(0)
 152 0038 0E94 0000 		call xQueueGenericCreate
 153 003c 9093 0000 		sts USART_ReadQueue+1,r25
 154 0040 8093 0000 		sts USART_ReadQueue,r24
  44:usart.c       **** 
  45:usart.c       ****     uint32_t ubrr = clk_speedin/(16UL)/baudin-1;
 156               	.LM3:
 157 0044 8F81      		ldd r24,Y+7
 158 0046 9885      		ldd r25,Y+8
 159 0048 A985      		ldd r26,Y+9
 160 004a BA85      		ldd r27,Y+10
 161 004c 6894      		set
 162 004e 13F8      		bld __zero_reg__,4-1
 163 0050 B695      	1:	lsr r27
 164 0052 A795      		ror r26
 165 0054 9795      		ror r25
 166 0056 8795      		ror r24
 167 0058 1694      		lsr __zero_reg__
 168 005a 01F4      		brne 1b
 169 005c 2D81      		ldd r18,Y+5
 170 005e 3E81      		ldd r19,Y+6
 171 0060 9901      		movw r18,r18
 172 0062 40E0      		ldi r20,lo8(0)
 173 0064 50E0      		ldi r21,hi8(0)
 174 0066 BC01      		movw r22,r24
 175 0068 CD01      		movw r24,r26
 176 006a 0E94 0000 		call __udivmodsi4
 177 006e DA01      		movw r26,r20
 178 0070 C901      		movw r24,r18
 179 0072 0197      		sbiw r24,1
 180 0074 A109      		sbc r26,__zero_reg__
 181 0076 B109      		sbc r27,__zero_reg__
 182 0078 8983      		std Y+1,r24
 183 007a 9A83      		std Y+2,r25
 184 007c AB83      		std Y+3,r26
 185 007e BC83      		std Y+4,r27
  46:usart.c       ****     UBRR0H = (unsigned char)(ubrr>>8) ;// & 0x7F;
 187               	.LM4:
 188 0080 25EC      		ldi r18,lo8(197)
 189 0082 30E0      		ldi r19,hi8(197)
 190 0084 8981      		ldd r24,Y+1
 191 0086 9A81      		ldd r25,Y+2
 192 0088 AB81      		ldd r26,Y+3
 193 008a BC81      		ldd r27,Y+4
 194 008c 892F      		mov r24,r25
 195 008e 9A2F      		mov r25,r26
 196 0090 AB2F      		mov r26,r27
 197 0092 BB27      		clr r27
 198 0094 F901      		movw r30,r18
 199 0096 8083      		st Z,r24
  47:usart.c       ****     UBRR0L = (unsigned char)ubrr;
 201               	.LM5:
 202 0098 84EC      		ldi r24,lo8(196)
 203 009a 90E0      		ldi r25,hi8(196)
 204 009c 2981      		ldd r18,Y+1
 205 009e FC01      		movw r30,r24
 206 00a0 2083      		st Z,r18
  48:usart.c       ****     
  49:usart.c       ****     //UBRR0H = 0; //115200
  50:usart.c       ****     //UBRR0L = 8;
  51:usart.c       **** 
  52:usart.c       ****     /* Enable receiver and transmitter */
  53:usart.c       ****     UCSR0B = (1<<RXEN1)|(1<<TXEN1)|(1<<RXCIE1);
 208               	.LM6:
 209 00a2 81EC      		ldi r24,lo8(193)
 210 00a4 90E0      		ldi r25,hi8(193)
 211 00a6 28E9      		ldi r18,lo8(-104)
 212 00a8 FC01      		movw r30,r24
 213 00aa 2083      		st Z,r18
  54:usart.c       ****     /* Set frame format: 8data, 1stop bit */
  55:usart.c       ****     UCSR0C = (1<<UCSZ11)|(1<<UCSZ10);
 215               	.LM7:
 216 00ac 82EC      		ldi r24,lo8(194)
 217 00ae 90E0      		ldi r25,hi8(194)
 218 00b0 26E0      		ldi r18,lo8(6)
 219 00b2 FC01      		movw r30,r24
 220 00b4 2083      		st Z,r18
  56:usart.c       **** 	 // clear U2X0 for Synchronous operation
  57:usart.c       ****     UCSR0A &= ~(1<<U2X1);
 222               	.LM8:
 223 00b6 80EC      		ldi r24,lo8(192)
 224 00b8 90E0      		ldi r25,hi8(192)
 225 00ba 20EC      		ldi r18,lo8(192)
 226 00bc 30E0      		ldi r19,hi8(192)
 227 00be F901      		movw r30,r18
 228 00c0 2081      		ld r18,Z
 229 00c2 2D7F      		andi r18,lo8(-3)
 230 00c4 FC01      		movw r30,r24
 231 00c6 2083      		st Z,r18
 232               	/* epilogue start */
  58:usart.c       **** 
  59:usart.c       ****     //UCSR0B |= (1<<UDRIE0);
  60:usart.c       **** 
  61:usart.c       ****     //PORTB = 0xFF;
  62:usart.c       **** 
  63:usart.c       ****     //UART0 Logging
  64:usart.c       **** 
  65:usart.c       ****     /*USART_WriteQueueLog = xQueueCreate(32,sizeof(uint8_t));
  66:usart.c       **** 
  67:usart.c       ****     ubrr = clk_speedin/(16UL)/baudin-1;
  68:usart.c       ****     UBRR0H = (unsigned char)(ubrr>>8) ;// & 0x7F;
  69:usart.c       ****     UBRR0L = (unsigned char)ubrr;
  70:usart.c       ****     
  71:usart.c       ****     //UBRR0H = 0; //115200
  72:usart.c       ****     //UBRR0L = 8;
  73:usart.c       **** 
  74:usart.c       ****     /* Enable receiver and transmitter */
  75:usart.c       ****     //UCSR0B = (1<<RXEN0)|(1<<TXEN0);
  76:usart.c       ****     /* Set frame format: 8data, 1stop bit */
  77:usart.c       ****     //UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
  78:usart.c       ****     // clear U2X0 for Synchronous operation
  79:usart.c       ****     //UCSR0A &= ~(1<<U2X0);*/
  80:usart.c       **** 
  81:usart.c       **** }
 234               	.LM9:
 235 00c8 2A96      		adiw r28,10
 236 00ca 0FB6      		in __tmp_reg__,__SREG__
 237 00cc F894      		cli
 238 00ce DEBF      		out __SP_H__,r29
 239 00d0 0FBE      		out __SREG__,__tmp_reg__
 240 00d2 CDBF      		out __SP_L__,r28
 241 00d4 CF91      		pop r28
 242 00d6 DF91      		pop r29
 243 00d8 0895      		ret
 248               	.Lscope1:
 250               		.stabd	78,0,0
 253               	.global	USART_Write
 255               	USART_Write:
 256               		.stabd	46,0,0
  82:usart.c       **** 
  83:usart.c       **** /*the send function will put 8bits on the trans line. */
  84:usart.c       **** void USART_Write(uint8_t data) {
 258               	.LM10:
 259               	.LFBB2:
 260 00da DF93      		push r29
 261 00dc CF93      		push r28
 262 00de 0F92      		push __tmp_reg__
 263 00e0 CDB7      		in r28,__SP_L__
 264 00e2 DEB7      		in r29,__SP_H__
 265               	/* prologue: function */
 266               	/* frame size = 1 */
 267               	/* stack size = 3 */
 268               	.L__stack_usage = 3
 269 00e4 8983      		std Y+1,r24
  85:usart.c       **** 		/* Wait for empty transmit buffer */
  86:usart.c       **** 		while ( !( UCSR0A & (1<<UDRE0)) )
 271               	.LM11:
 272 00e6 0000      		nop
 273               	.L3:
 275               	.LM12:
 276 00e8 80EC      		ldi r24,lo8(192)
 277 00ea 90E0      		ldi r25,hi8(192)
 278 00ec FC01      		movw r30,r24
 279 00ee 8081      		ld r24,Z
 280 00f0 882F      		mov r24,r24
 281 00f2 90E0      		ldi r25,lo8(0)
 282 00f4 8072      		andi r24,lo8(32)
 283 00f6 9070      		andi r25,hi8(32)
 284 00f8 0097      		sbiw r24,0
 285 00fa 01F0      		breq .L3
  87:usart.c       **** 		;
  88:usart.c       **** 		/* Put data into buffer, sends the data */
  89:usart.c       **** 		UDR0 = data;
 287               	.LM13:
 288 00fc 86EC      		ldi r24,lo8(198)
 289 00fe 90E0      		ldi r25,hi8(198)
 290 0100 2981      		ldd r18,Y+1
 291 0102 FC01      		movw r30,r24
 292 0104 2083      		st Z,r18
 293               	/* epilogue start */
  90:usart.c       **** }
 295               	.LM14:
 296 0106 0F90      		pop __tmp_reg__
 297 0108 CF91      		pop r28
 298 010a DF91      		pop r29
 299 010c 0895      		ret
 301               	.Lscope2:
 303               		.stabd	78,0,0
 306               	.global	USART_Write_Unprotected
 308               	USART_Write_Unprotected:
 309               		.stabd	46,0,0
  91:usart.c       **** 
  92:usart.c       **** /*the send function will put 8bits on the trans line. */
  93:usart.c       **** void USART_Write_Unprotected(uint8_t data) {
 311               	.LM15:
 312               	.LFBB3:
 313 010e DF93      		push r29
 314 0110 CF93      		push r28
 315 0112 0F92      		push __tmp_reg__
 316 0114 CDB7      		in r28,__SP_L__
 317 0116 DEB7      		in r29,__SP_H__
 318               	/* prologue: function */
 319               	/* frame size = 1 */
 320               	/* stack size = 3 */
 321               	.L__stack_usage = 3
 322 0118 8983      		std Y+1,r24
  94:usart.c       **** 	/* Wait for empty transmit buffer */
  95:usart.c       **** 	while ( !( UCSR0A & (1<<UDRE0)) )
 324               	.LM16:
 325 011a 0000      		nop
 326               	.L5:
 328               	.LM17:
 329 011c 80EC      		ldi r24,lo8(192)
 330 011e 90E0      		ldi r25,hi8(192)
 331 0120 FC01      		movw r30,r24
 332 0122 8081      		ld r24,Z
 333 0124 882F      		mov r24,r24
 334 0126 90E0      		ldi r25,lo8(0)
 335 0128 8072      		andi r24,lo8(32)
 336 012a 9070      		andi r25,hi8(32)
 337 012c 0097      		sbiw r24,0
 338 012e 01F0      		breq .L5
  96:usart.c       **** 	;
  97:usart.c       **** 	/* Put data into buffer, sends the data */
  98:usart.c       **** 	UDR0 = data;
 340               	.LM18:
 341 0130 86EC      		ldi r24,lo8(198)
 342 0132 90E0      		ldi r25,hi8(198)
 343 0134 2981      		ldd r18,Y+1
 344 0136 FC01      		movw r30,r24
 345 0138 2083      		st Z,r18
 346               	/* epilogue start */
  99:usart.c       **** }
 348               	.LM19:
 349 013a 0F90      		pop __tmp_reg__
 350 013c CF91      		pop r28
 351 013e DF91      		pop r29
 352 0140 0895      		ret
 354               	.Lscope3:
 356               		.stabd	78,0,0
 358               	.global	USART_Read
 360               	USART_Read:
 361               		.stabd	46,0,0
 100:usart.c       **** 
 101:usart.c       **** /* the receive data function. Note that this a blocking call
 102:usart.c       **** Therefore you may not get control back after this is called 
 103:usart.c       **** until a much later time. It may be helpful to use the 
 104:usart.c       **** istheredata() function to check before calling this function
 105:usart.c       ****         @return 8bit data packet from sender
 106:usart.c       **** */
 107:usart.c       **** uint8_t USART_Read(void) {
 363               	.LM20:
 364               	.LFBB4:
 365 0142 DF93      		push r29
 366 0144 CF93      		push r28
 367 0146 CDB7      		in r28,__SP_L__
 368 0148 DEB7      		in r29,__SP_H__
 369               	/* prologue: function */
 370               	/* frame size = 0 */
 371               	/* stack size = 2 */
 372               	.L__stack_usage = 2
 108:usart.c       ****     /* Wait for data to be received */
 109:usart.c       ****     while ( !(UCSR0A & (1<<RXC0)) )
 374               	.LM21:
 375 014a 0000      		nop
 376               	.L7:
 378               	.LM22:
 379 014c 80EC      		ldi r24,lo8(192)
 380 014e 90E0      		ldi r25,hi8(192)
 381 0150 FC01      		movw r30,r24
 382 0152 8081      		ld r24,Z
 383 0154 8823      		tst r24
 384 0156 04F4      		brge .L7
 110:usart.c       ****         ;
 111:usart.c       ****     /* Get and return received data from buffer */
 112:usart.c       ****     return UDR0;
 386               	.LM23:
 387 0158 86EC      		ldi r24,lo8(198)
 388 015a 90E0      		ldi r25,hi8(198)
 389 015c FC01      		movw r30,r24
 390 015e 8081      		ld r24,Z
 391               	/* epilogue start */
 113:usart.c       **** }
 393               	.LM24:
 394 0160 CF91      		pop r28
 395 0162 DF91      		pop r29
 396 0164 0895      		ret
 398               	.Lscope4:
 400               		.stabd	78,0,0
 402               	.global	__vector_36
 404               	__vector_36:
 405               		.stabd	46,0,0
 114:usart.c       **** 
 115:usart.c       **** 
 116:usart.c       **** ISR(USART1_RX_vect){
 407               	.LM25:
 408               	.LFBB5:
 409 0166 1F92      		push __zero_reg__
 410 0168 0F92      		push r0
 411 016a 0FB6      		in r0,__SREG__
 412 016c 0F92      		push r0
 413 016e 0090 5B00 		lds r0,91
 414 0172 0F92      		push r0
 415 0174 1124      		clr __zero_reg__
 416 0176 2F93      		push r18
 417 0178 3F93      		push r19
 418 017a 4F93      		push r20
 419 017c 5F93      		push r21
 420 017e 6F93      		push r22
 421 0180 7F93      		push r23
 422 0182 8F93      		push r24
 423 0184 9F93      		push r25
 424 0186 AF93      		push r26
 425 0188 BF93      		push r27
 426 018a EF93      		push r30
 427 018c FF93      		push r31
 428 018e DF93      		push r29
 429 0190 CF93      		push r28
 430 0192 0F92      		push __tmp_reg__
 431 0194 CDB7      		in r28,__SP_L__
 432 0196 DEB7      		in r29,__SP_H__
 433               	/* prologue: Signal */
 434               	/* frame size = 1 */
 435               	/* stack size = 19 */
 436               	.L__stack_usage = 19
 117:usart.c       ****     uint8_t data;
 118:usart.c       ****     data = UDR1;
 438               	.LM26:
 439 0198 8EEC      		ldi r24,lo8(206)
 440 019a 90E0      		ldi r25,hi8(206)
 441 019c FC01      		movw r30,r24
 442 019e 8081      		ld r24,Z
 443 01a0 8983      		std Y+1,r24
 119:usart.c       ****     //USART_AddToQueue(data);
 120:usart.c       ****     xQueueSendToBackFromISR(USART_ReadQueue,&data,NULL);
 445               	.LM27:
 446 01a2 8091 0000 		lds r24,USART_ReadQueue
 447 01a6 9091 0000 		lds r25,USART_ReadQueue+1
 448 01aa 9E01      		movw r18,r28
 449 01ac 2F5F      		subi r18,lo8(-(1))
 450 01ae 3F4F      		sbci r19,hi8(-(1))
 451 01b0 B901      		movw r22,r18
 452 01b2 40E0      		ldi r20,lo8(0)
 453 01b4 50E0      		ldi r21,hi8(0)
 454 01b6 20E0      		ldi r18,lo8(0)
 455 01b8 0E94 0000 		call xQueueGenericSendFromISR
 456               	/* epilogue start */
 121:usart.c       **** }
 458               	.LM28:
 459 01bc 0F90      		pop __tmp_reg__
 460 01be CF91      		pop r28
 461 01c0 DF91      		pop r29
 462 01c2 FF91      		pop r31
 463 01c4 EF91      		pop r30
 464 01c6 BF91      		pop r27
 465 01c8 AF91      		pop r26
 466 01ca 9F91      		pop r25
 467 01cc 8F91      		pop r24
 468 01ce 7F91      		pop r23
 469 01d0 6F91      		pop r22
 470 01d2 5F91      		pop r21
 471 01d4 4F91      		pop r20
 472 01d6 3F91      		pop r19
 473 01d8 2F91      		pop r18
 474 01da 0F90      		pop r0
 475 01dc 0092 5B00 		sts 91,r0
 476 01e0 0F90      		pop r0
 477 01e2 0FBE      		out __SREG__,r0
 478 01e4 0F90      		pop r0
 479 01e6 1F90      		pop __zero_reg__
 480 01e8 1895      		reti
 485               	.Lscope5:
 487               		.stabd	78,0,0
 490               	.global	USART_AddToQueue
 492               	USART_AddToQueue:
 493               		.stabd	46,0,0
 122:usart.c       **** 
 123:usart.c       **** void USART_AddToQueue(uint8_t data){
 495               	.LM29:
 496               	.LFBB6:
 497 01ea DF93      		push r29
 498 01ec CF93      		push r28
 499 01ee 0F92      		push __tmp_reg__
 500 01f0 CDB7      		in r28,__SP_L__
 501 01f2 DEB7      		in r29,__SP_H__
 502               	/* prologue: function */
 503               	/* frame size = 1 */
 504               	/* stack size = 3 */
 505               	.L__stack_usage = 3
 506 01f4 8983      		std Y+1,r24
 124:usart.c       ****     
 125:usart.c       ****     xQueueSendToBack(USART_WriteQueue,&data,portMAX_DELAY);
 508               	.LM30:
 509 01f6 8091 0000 		lds r24,USART_WriteQueue
 510 01fa 9091 0000 		lds r25,USART_WriteQueue+1
 511 01fe 9E01      		movw r18,r28
 512 0200 2F5F      		subi r18,lo8(-(1))
 513 0202 3F4F      		sbci r19,hi8(-(1))
 514 0204 B901      		movw r22,r18
 515 0206 4FEF      		ldi r20,lo8(-1)
 516 0208 5FEF      		ldi r21,hi8(-1)
 517 020a 20E0      		ldi r18,lo8(0)
 518 020c 0E94 0000 		call xQueueGenericSend
 519               	/* epilogue start */
 126:usart.c       **** 
 127:usart.c       **** }
 521               	.LM31:
 522 0210 0F90      		pop __tmp_reg__
 523 0212 CF91      		pop r28
 524 0214 DF91      		pop r29
 525 0216 0895      		ret
 527               	.Lscope6:
 529               		.stabd	78,0,0
 532               	.global	USART_TransmitString
 534               	USART_TransmitString:
 535               		.stabd	46,0,0
 128:usart.c       **** 
 129:usart.c       **** void USART_TransmitString(char* str){
 537               	.LM32:
 538               	.LFBB7:
 539 0218 DF93      		push r29
 540 021a CF93      		push r28
 541 021c 0F92      		push __tmp_reg__
 542 021e 0F92      		push __tmp_reg__
 543 0220 CDB7      		in r28,__SP_L__
 544 0222 DEB7      		in r29,__SP_H__
 545               	/* prologue: function */
 546               	/* frame size = 2 */
 547               	/* stack size = 4 */
 548               	.L__stack_usage = 4
 549 0224 9A83      		std Y+2,r25
 550 0226 8983      		std Y+1,r24
 130:usart.c       ****     while(*str) {
 552               	.LM33:
 553 0228 00C0      		rjmp .L11
 554               	.L12:
 131:usart.c       ****         USART_AddToQueue(*str);
 556               	.LM34:
 557 022a 8981      		ldd r24,Y+1
 558 022c 9A81      		ldd r25,Y+2
 559 022e FC01      		movw r30,r24
 560 0230 8081      		ld r24,Z
 561 0232 0E94 0000 		call USART_AddToQueue
 132:usart.c       ****         str++;
 563               	.LM35:
 564 0236 8981      		ldd r24,Y+1
 565 0238 9A81      		ldd r25,Y+2
 566 023a 0196      		adiw r24,1
 567 023c 9A83      		std Y+2,r25
 568 023e 8983      		std Y+1,r24
 569               	.L11:
 130:usart.c       ****     while(*str) {
 571               	.LM36:
 572 0240 8981      		ldd r24,Y+1
 573 0242 9A81      		ldd r25,Y+2
 574 0244 FC01      		movw r30,r24
 575 0246 8081      		ld r24,Z
 576 0248 8823      		tst r24
 577 024a 01F4      		brne .L12
 578               	/* epilogue start */
 133:usart.c       ****     }
 134:usart.c       **** }
 580               	.LM37:
 581 024c 0F90      		pop __tmp_reg__
 582 024e 0F90      		pop __tmp_reg__
 583 0250 CF91      		pop r28
 584 0252 DF91      		pop r29
 585 0254 0895      		ret
 587               	.Lscope7:
 589               		.stabd	78,0,0
 592               	.global	vTaskUSARTWrite
 594               	vTaskUSARTWrite:
 595               		.stabd	46,0,0
 135:usart.c       **** 
 136:usart.c       **** void vTaskUSARTWrite(void *pvParameters){
 597               	.LM38:
 598               	.LFBB8:
 599 0256 DF93      		push r29
 600 0258 CF93      		push r28
 601 025a 00D0      		rcall .
 602 025c CDB7      		in r28,__SP_L__
 603 025e DEB7      		in r29,__SP_H__
 604               	/* prologue: function */
 605               	/* frame size = 3 */
 606               	/* stack size = 5 */
 607               	.L__stack_usage = 5
 608 0260 9B83      		std Y+3,r25
 609 0262 8A83      		std Y+2,r24
 610               	.L15:
 137:usart.c       ****     uint8_t data;
 138:usart.c       ****     while(1){
 139:usart.c       ****     xQueueReceive(USART_WriteQueue,&data,portMAX_DELAY);
 612               	.LM39:
 613 0264 8091 0000 		lds r24,USART_WriteQueue
 614 0268 9091 0000 		lds r25,USART_WriteQueue+1
 615 026c 9E01      		movw r18,r28
 616 026e 2F5F      		subi r18,lo8(-(1))
 617 0270 3F4F      		sbci r19,hi8(-(1))
 618 0272 B901      		movw r22,r18
 619 0274 4FEF      		ldi r20,lo8(-1)
 620 0276 5FEF      		ldi r21,hi8(-1)
 621 0278 20E0      		ldi r18,lo8(0)
 622 027a 0E94 0000 		call xQueueGenericReceive
 140:usart.c       **** 
 141:usart.c       ****         while(!(UCSR0A & (1<<UDRE0)));
 624               	.LM40:
 625 027e 0000      		nop
 626               	.L14:
 628               	.LM41:
 629 0280 80EC      		ldi r24,lo8(192)
 630 0282 90E0      		ldi r25,hi8(192)
 631 0284 FC01      		movw r30,r24
 632 0286 8081      		ld r24,Z
 633 0288 882F      		mov r24,r24
 634 028a 90E0      		ldi r25,lo8(0)
 635 028c 8072      		andi r24,lo8(32)
 636 028e 9070      		andi r25,hi8(32)
 637 0290 0097      		sbiw r24,0
 638 0292 01F0      		breq .L14
 142:usart.c       ****         UDR1 = data;
 640               	.LM42:
 641 0294 8EEC      		ldi r24,lo8(206)
 642 0296 90E0      		ldi r25,hi8(206)
 643 0298 2981      		ldd r18,Y+1
 644 029a FC01      		movw r30,r24
 645 029c 2083      		st Z,r18
 143:usart.c       **** 
 144:usart.c       ****     }
 647               	.LM43:
 648 029e 00C0      		rjmp .L15
 653               	.Lscope8:
 655               		.stabd	78,0,0
 658               	.global	USART_LogChar
 660               	USART_LogChar:
 661               		.stabd	46,0,0
 145:usart.c       **** }
 146:usart.c       **** 
 147:usart.c       **** void USART_LogChar(uint8_t data){
 663               	.LM44:
 664               	.LFBB9:
 665 02a0 DF93      		push r29
 666 02a2 CF93      		push r28
 667 02a4 0F92      		push __tmp_reg__
 668 02a6 CDB7      		in r28,__SP_L__
 669 02a8 DEB7      		in r29,__SP_H__
 670               	/* prologue: function */
 671               	/* frame size = 1 */
 672               	/* stack size = 3 */
 673               	.L__stack_usage = 3
 674 02aa 8983      		std Y+1,r24
 148:usart.c       ****     xQueueSendToBack(USART_WriteQueueLog,&data,portMAX_DELAY);
 676               	.LM45:
 677 02ac 8091 0000 		lds r24,USART_WriteQueueLog
 678 02b0 9091 0000 		lds r25,USART_WriteQueueLog+1
 679 02b4 9E01      		movw r18,r28
 680 02b6 2F5F      		subi r18,lo8(-(1))
 681 02b8 3F4F      		sbci r19,hi8(-(1))
 682 02ba B901      		movw r22,r18
 683 02bc 4FEF      		ldi r20,lo8(-1)
 684 02be 5FEF      		ldi r21,hi8(-1)
 685 02c0 20E0      		ldi r18,lo8(0)
 686 02c2 0E94 0000 		call xQueueGenericSend
 687               	/* epilogue start */
 149:usart.c       **** }
 689               	.LM46:
 690 02c6 0F90      		pop __tmp_reg__
 691 02c8 CF91      		pop r28
 692 02ca DF91      		pop r29
 693 02cc 0895      		ret
 695               	.Lscope9:
 697               		.stabd	78,0,0
 700               	.global	USART_LogString
 702               	USART_LogString:
 703               		.stabd	46,0,0
 150:usart.c       **** 
 151:usart.c       **** void USART_LogString(char* str){
 705               	.LM47:
 706               	.LFBB10:
 707 02ce DF93      		push r29
 708 02d0 CF93      		push r28
 709 02d2 0F92      		push __tmp_reg__
 710 02d4 0F92      		push __tmp_reg__
 711 02d6 CDB7      		in r28,__SP_L__
 712 02d8 DEB7      		in r29,__SP_H__
 713               	/* prologue: function */
 714               	/* frame size = 2 */
 715               	/* stack size = 4 */
 716               	.L__stack_usage = 4
 717 02da 9A83      		std Y+2,r25
 718 02dc 8983      		std Y+1,r24
 152:usart.c       ****     while(*str){
 720               	.LM48:
 721 02de 00C0      		rjmp .L18
 722               	.L19:
 153:usart.c       ****         USART_LogChar(*str);
 724               	.LM49:
 725 02e0 8981      		ldd r24,Y+1
 726 02e2 9A81      		ldd r25,Y+2
 727 02e4 FC01      		movw r30,r24
 728 02e6 8081      		ld r24,Z
 729 02e8 0E94 0000 		call USART_LogChar
 154:usart.c       ****         str++;
 731               	.LM50:
 732 02ec 8981      		ldd r24,Y+1
 733 02ee 9A81      		ldd r25,Y+2
 734 02f0 0196      		adiw r24,1
 735 02f2 9A83      		std Y+2,r25
 736 02f4 8983      		std Y+1,r24
 737               	.L18:
 152:usart.c       ****     while(*str){
 739               	.LM51:
 740 02f6 8981      		ldd r24,Y+1
 741 02f8 9A81      		ldd r25,Y+2
 742 02fa FC01      		movw r30,r24
 743 02fc 8081      		ld r24,Z
 744 02fe 8823      		tst r24
 745 0300 01F4      		brne .L19
 746               	/* epilogue start */
 155:usart.c       ****     }
 156:usart.c       **** }
 748               	.LM52:
 749 0302 0F90      		pop __tmp_reg__
 750 0304 0F90      		pop __tmp_reg__
 751 0306 CF91      		pop r28
 752 0308 DF91      		pop r29
 753 030a 0895      		ret
 755               	.Lscope10:
 757               		.stabd	78,0,0
 760               	.global	vTaskUSARTLog
 762               	vTaskUSARTLog:
 763               		.stabd	46,0,0
 157:usart.c       **** 
 158:usart.c       **** void vTaskUSARTLog(void *pvParameters){
 765               	.LM53:
 766               	.LFBB11:
 767 030c DF93      		push r29
 768 030e CF93      		push r28
 769 0310 00D0      		rcall .
 770 0312 CDB7      		in r28,__SP_L__
 771 0314 DEB7      		in r29,__SP_H__
 772               	/* prologue: function */
 773               	/* frame size = 3 */
 774               	/* stack size = 5 */
 775               	.L__stack_usage = 5
 776 0316 9B83      		std Y+3,r25
 777 0318 8A83      		std Y+2,r24
 778               	.L22:
 159:usart.c       ****     uint8_t data;
 160:usart.c       ****     while(1){
 161:usart.c       ****         xQueueReceive(USART_WriteQueueLog,&data,portMAX_DELAY);
 780               	.LM54:
 781 031a 8091 0000 		lds r24,USART_WriteQueueLog
 782 031e 9091 0000 		lds r25,USART_WriteQueueLog+1
 783 0322 9E01      		movw r18,r28
 784 0324 2F5F      		subi r18,lo8(-(1))
 785 0326 3F4F      		sbci r19,hi8(-(1))
 786 0328 B901      		movw r22,r18
 787 032a 4FEF      		ldi r20,lo8(-1)
 788 032c 5FEF      		ldi r21,hi8(-1)
 789 032e 20E0      		ldi r18,lo8(0)
 790 0330 0E94 0000 		call xQueueGenericReceive
 162:usart.c       **** 
 163:usart.c       ****         while(!(UCSR0A & (1<<UDRE0)));
 792               	.LM55:
 793 0334 0000      		nop
 794               	.L21:
 796               	.LM56:
 797 0336 80EC      		ldi r24,lo8(192)
 798 0338 90E0      		ldi r25,hi8(192)
 799 033a FC01      		movw r30,r24
 800 033c 8081      		ld r24,Z
 801 033e 882F      		mov r24,r24
 802 0340 90E0      		ldi r25,lo8(0)
 803 0342 8072      		andi r24,lo8(32)
 804 0344 9070      		andi r25,hi8(32)
 805 0346 0097      		sbiw r24,0
 806 0348 01F0      		breq .L21
 164:usart.c       ****         UDR0 = data;
 808               	.LM57:
 809 034a 86EC      		ldi r24,lo8(198)
 810 034c 90E0      		ldi r25,hi8(198)
 811 034e 2981      		ldd r18,Y+1
 812 0350 FC01      		movw r30,r24
 813 0352 2083      		st Z,r18
 165:usart.c       **** 
 166:usart.c       ****     }
 815               	.LM58:
 816 0354 00C0      		rjmp .L22
 821               	.Lscope11:
 823               		.stabd	78,0,0
 825               	.global	USART_GetChar
 827               	USART_GetChar:
 828               		.stabd	46,0,0
 167:usart.c       **** 
 168:usart.c       **** }
 169:usart.c       **** 
 170:usart.c       **** uint8_t USART_GetChar(){
 830               	.LM59:
 831               	.LFBB12:
 832 0356 DF93      		push r29
 833 0358 CF93      		push r28
 834 035a 0F92      		push __tmp_reg__
 835 035c CDB7      		in r28,__SP_L__
 836 035e DEB7      		in r29,__SP_H__
 837               	/* prologue: function */
 838               	/* frame size = 1 */
 839               	/* stack size = 3 */
 840               	.L__stack_usage = 3
 171:usart.c       ****     uint8_t data;
 172:usart.c       ****     if(xQueueReceive(USART_ReadQueue,&data,1) == pdTRUE){
 842               	.LM60:
 843 0360 8091 0000 		lds r24,USART_ReadQueue
 844 0364 9091 0000 		lds r25,USART_ReadQueue+1
 845 0368 9E01      		movw r18,r28
 846 036a 2F5F      		subi r18,lo8(-(1))
 847 036c 3F4F      		sbci r19,hi8(-(1))
 848 036e B901      		movw r22,r18
 849 0370 41E0      		ldi r20,lo8(1)
 850 0372 50E0      		ldi r21,hi8(1)
 851 0374 20E0      		ldi r18,lo8(0)
 852 0376 0E94 0000 		call xQueueGenericReceive
 853 037a 8130      		cpi r24,lo8(1)
 854 037c 01F4      		brne .L24
 173:usart.c       ****         //USART_AddToQueue('~');
 174:usart.c       ****         return data;
 856               	.LM61:
 857 037e 8981      		ldd r24,Y+1
 858 0380 00C0      		rjmp .L25
 859               	.L24:
 175:usart.c       ****     } else {
 176:usart.c       ****         return 255;
 861               	.LM62:
 862 0382 8FEF      		ldi r24,lo8(-1)
 863               	.L25:
 864               	/* epilogue start */
 177:usart.c       ****     }
 178:usart.c       **** }
 866               	.LM63:
 867 0384 0F90      		pop __tmp_reg__
 868 0386 CF91      		pop r28
 869 0388 DF91      		pop r29
 870 038a 0895      		ret
 875               	.Lscope12:
 877               		.stabd	78,0,0
 880               	.global	vTaskUSARTRead
 882               	vTaskUSARTRead:
 883               		.stabd	46,0,0
 179:usart.c       **** 
 180:usart.c       **** void vTaskUSARTRead(void *pvParameters){
 885               	.LM64:
 886               	.LFBB13:
 887 038c DF93      		push r29
 888 038e CF93      		push r28
 889 0390 CDB7      		in r28,__SP_L__
 890 0392 DEB7      		in r29,__SP_H__
 891 0394 C455      		subi r28,lo8(-(-84))
 892 0396 D040      		sbci r29,hi8(-(-84))
 893 0398 0FB6      		in __tmp_reg__,__SREG__
 894 039a F894      		cli
 895 039c DEBF      		out __SP_H__,r29
 896 039e 0FBE      		out __SREG__,__tmp_reg__
 897 03a0 CDBF      		out __SP_L__,r28
 898               	/* prologue: function */
 899               	/* frame size = 84 */
 900               	/* stack size = 86 */
 901               	.L__stack_usage = 86
 902 03a2 9E01      		movw r18,r28
 903 03a4 2D5A      		subi r18,lo8(-(83))
 904 03a6 3F4F      		sbci r19,hi8(-(83))
 905 03a8 F901      		movw r30,r18
 906 03aa 9183      		std Z+1,r25
 907 03ac 8083      		st Z,r24
 181:usart.c       **** 
 182:usart.c       ****     char bytesRecieved;
 183:usart.c       ****     uint8_t rxData;
 184:usart.c       ****     uint8_t buffer[8];
 185:usart.c       ****     char size;
 186:usart.c       ****     char groupID;
 187:usart.c       ****     char cmd;
 188:usart.c       ****     unsigned int timeout;
 189:usart.c       **** 
 190:usart.c       ****     PORTB = 0;
 909               	.LM65:
 910 03ae 85E2      		ldi r24,lo8(37)
 911 03b0 90E0      		ldi r25,hi8(37)
 912 03b2 FC01      		movw r30,r24
 913 03b4 1082      		st Z,__zero_reg__
 914               	.L41:
 191:usart.c       **** 
 192:usart.c       ****     Command command;
 193:usart.c       ****     Response response;
 194:usart.c       ****     while(1){
 195:usart.c       ****         //PORTB = 0;
 196:usart.c       ****         //Get Header
 197:usart.c       ****         bytesRecieved = 0;
 916               	.LM66:
 917 03b6 1982      		std Y+1,__zero_reg__
 198:usart.c       ****         timeout = 0;
 919               	.LM67:
 920 03b8 1B82      		std Y+3,__zero_reg__
 921 03ba 1A82      		std Y+2,__zero_reg__
 199:usart.c       ****         while(bytesRecieved < 4){
 923               	.LM68:
 924 03bc 00C0      		rjmp .L27
 925               	.L30:
 200:usart.c       ****             //if there is data to be read...
 201:usart.c       ****             //if((UCSR1A & (1<<RXC1))){
 202:usart.c       ****             //    rxData = UDR1;
 203:usart.c       ****             if((rxData = USART_GetChar()) != 255){
 927               	.LM69:
 928 03be 0E94 0000 		call USART_GetChar
 929 03c2 8C83      		std Y+4,r24
 930 03c4 8C81      		ldd r24,Y+4
 931 03c6 8F3F      		cpi r24,lo8(-1)
 932 03c8 01F0      		breq .L28
 204:usart.c       ****             //if(xQueueReceive(USART_ReadQueue,&rxData,portMAX_DELAY) == pdTRUE){
 205:usart.c       ****                 buffer[bytesRecieved] = rxData;
 934               	.LM70:
 935 03ca 8981      		ldd r24,Y+1
 936 03cc 9927      		clr r25
 937 03ce 87FD      		sbrc r24,7
 938 03d0 9095      		com r25
 939 03d2 9E01      		movw r18,r28
 940 03d4 2A5F      		subi r18,lo8(-(6))
 941 03d6 3F4F      		sbci r19,hi8(-(6))
 942 03d8 820F      		add r24,r18
 943 03da 931F      		adc r25,r19
 944 03dc 2C81      		ldd r18,Y+4
 945 03de FC01      		movw r30,r24
 946 03e0 2083      		st Z,r18
 206:usart.c       ****                 //USART_AddToQueue(rxData);
 207:usart.c       ****                 bytesRecieved++;
 948               	.LM71:
 949 03e2 8981      		ldd r24,Y+1
 950 03e4 8F5F      		subi r24,lo8(-(1))
 951 03e6 8983      		std Y+1,r24
 952 03e8 00C0      		rjmp .L29
 953               	.L28:
 208:usart.c       ****                 //timeout = 0;
 209:usart.c       ****             } else {
 210:usart.c       ****                 timeout++;
 955               	.LM72:
 956 03ea 8A81      		ldd r24,Y+2
 957 03ec 9B81      		ldd r25,Y+3
 958 03ee 0196      		adiw r24,1
 959 03f0 9B83      		std Y+3,r25
 960 03f2 8A83      		std Y+2,r24
 211:usart.c       ****                 PORTB = 0xFF;
 962               	.LM73:
 963 03f4 85E2      		ldi r24,lo8(37)
 964 03f6 90E0      		ldi r25,hi8(37)
 965 03f8 2FEF      		ldi r18,lo8(-1)
 966 03fa FC01      		movw r30,r24
 967 03fc 2083      		st Z,r18
 968               	.L29:
 212:usart.c       ****             }
 213:usart.c       ****             if(timeout > 50000){
 970               	.LM74:
 971 03fe 8A81      		ldd r24,Y+2
 972 0400 9B81      		ldd r25,Y+3
 973 0402 F3EC      		ldi r31,hi8(-15535)
 974 0404 8135      		cpi r24,lo8(-15535)
 975 0406 9F07      		cpc r25,r31
 976 0408 00F0      		brlo .L27
 214:usart.c       ****                 timeout = 0;
 978               	.LM75:
 979 040a 1B82      		std Y+3,__zero_reg__
 980 040c 1A82      		std Y+2,__zero_reg__
 215:usart.c       ****                 bytesRecieved = 0;
 982               	.LM76:
 983 040e 1982      		std Y+1,__zero_reg__
 984               	.L27:
 199:usart.c       ****         while(bytesRecieved < 4){
 986               	.LM77:
 987 0410 8981      		ldd r24,Y+1
 988 0412 8430      		cpi r24,lo8(4)
 989 0414 04F0      		brlt .L30
 216:usart.c       ****             }
 217:usart.c       ****         }
 218:usart.c       ****         //PORTB = 0;
 219:usart.c       ****         if(calcChecksum(buffer,3) != buffer[3]){
 991               	.LM78:
 992 0416 CE01      		movw r24,r28
 993 0418 0696      		adiw r24,6
 994 041a 63E0      		ldi r22,lo8(3)
 995 041c 0E94 0000 		call calcChecksum
 996 0420 982F      		mov r25,r24
 997 0422 8985      		ldd r24,Y+9
 998 0424 9817      		cp r25,r24
 999 0426 01F0      		breq .L31
 220:usart.c       ****             sendNACK();
 1001               	.LM79:
 1002 0428 0E94 0000 		call sendNACK
 221:usart.c       ****         } else {
 222:usart.c       ****             sendACK();
 223:usart.c       ****             bytesRecieved = 0;
 224:usart.c       ****             command.groupID = buffer[0];
 225:usart.c       ****             command.cmd = buffer[1];
 226:usart.c       ****             command.crc = buffer[3];
 227:usart.c       ****             size = buffer[2];
 228:usart.c       ****             timeout = 0;
 229:usart.c       ****             if(size != 0){
 230:usart.c       ****                 while(1) {
 231:usart.c       ****                     while((bytesRecieved < size+1) && (timeout < 50)){  //1 for crc
 232:usart.c       ****                         if(UCSR1A & (1<<RXC1)){
 233:usart.c       ****                             rxData = UDR1;
 234:usart.c       **** 
 235:usart.c       ****                             //PORTB = 0xFF;
 236:usart.c       ****                         //if(xQueueReceive(USART_ReadQueue,&rxData,portMAX_DELAY) == pdTRUE){
 237:usart.c       ****                             buffer[bytesRecieved] = rxData;
 238:usart.c       ****                             bytesRecieved++;
 239:usart.c       ****                         } else {
 240:usart.c       ****                             //timeout++;
 241:usart.c       ****                             timeout = 1;
 242:usart.c       ****                         }
 243:usart.c       ****                     } 
 244:usart.c       ****                     if(timeout >= 50){
 245:usart.c       ****                         break;
 246:usart.c       ****                     }
 247:usart.c       ****                     if(calcChecksum(buffer,size) != buffer[size]){
 248:usart.c       ****                         sendNACK();
 249:usart.c       ****                         bytesRecieved = 0;
 250:usart.c       ****                     } else {
 251:usart.c       ****                         //PORTB = buffer[0];
 252:usart.c       ****                         sendACK();
 253:usart.c       ****                         memcpy(command.payload,buffer,size);
 254:usart.c       ****                         break;
 255:usart.c       ****                     }
 256:usart.c       ****                 }
 257:usart.c       ****             }
 258:usart.c       ****             processCommand(&command,&response);
 259:usart.c       ****             sendResponse(&response);
 260:usart.c       **** 
 261:usart.c       ****         }
 262:usart.c       **** 
 263:usart.c       ****     }
 1004               	.LM80:
 1005 042c 00C0      		rjmp .L41
 1006               	.L31:
 1007               	.LBB2:
 222:usart.c       ****             sendACK();
 1009               	.LM81:
 1010 042e 0E94 0000 		call sendACK
 223:usart.c       ****             bytesRecieved = 0;
 1012               	.LM82:
 1013 0432 1982      		std Y+1,__zero_reg__
 224:usart.c       ****             command.groupID = buffer[0];
 1015               	.LM83:
 1016 0434 8E81      		ldd r24,Y+6
 1017 0436 8E87      		std Y+14,r24
 225:usart.c       ****             command.cmd = buffer[1];
 1019               	.LM84:
 1020 0438 8F81      		ldd r24,Y+7
 1021 043a 8F87      		std Y+15,r24
 226:usart.c       ****             command.crc = buffer[3];
 1023               	.LM85:
 1024 043c 8985      		ldd r24,Y+9
 1025 043e 888B      		std Y+16,r24
 227:usart.c       ****             size = buffer[2];
 1027               	.LM86:
 1028 0440 8885      		ldd r24,Y+8
 1029 0442 8D83      		std Y+5,r24
 228:usart.c       ****             timeout = 0;
 1031               	.LM87:
 1032 0444 1B82      		std Y+3,__zero_reg__
 1033 0446 1A82      		std Y+2,__zero_reg__
 229:usart.c       ****             if(size != 0){
 1035               	.LM88:
 1036 0448 8D81      		ldd r24,Y+5
 1037 044a 8823      		tst r24
 1038 044c 01F4      		brne .+2
 1039 044e 00C0      		rjmp .L33
 231:usart.c       ****                     while((bytesRecieved < size+1) && (timeout < 50)){  //1 for crc
 1041               	.LM89:
 1042 0450 00C0      		rjmp .L34
 1043               	.L37:
 232:usart.c       ****                         if(UCSR1A & (1<<RXC1)){
 1045               	.LM90:
 1046 0452 88EC      		ldi r24,lo8(200)
 1047 0454 90E0      		ldi r25,hi8(200)
 1048 0456 FC01      		movw r30,r24
 1049 0458 8081      		ld r24,Z
 1050 045a 8823      		tst r24
 1051 045c 04F4      		brge .L35
 233:usart.c       ****                             rxData = UDR1;
 1053               	.LM91:
 1054 045e 8EEC      		ldi r24,lo8(206)
 1055 0460 90E0      		ldi r25,hi8(206)
 1056 0462 FC01      		movw r30,r24
 1057 0464 8081      		ld r24,Z
 1058 0466 8C83      		std Y+4,r24
 237:usart.c       ****                             buffer[bytesRecieved] = rxData;
 1060               	.LM92:
 1061 0468 8981      		ldd r24,Y+1
 1062 046a 9927      		clr r25
 1063 046c 87FD      		sbrc r24,7
 1064 046e 9095      		com r25
 1065 0470 9E01      		movw r18,r28
 1066 0472 2A5F      		subi r18,lo8(-(6))
 1067 0474 3F4F      		sbci r19,hi8(-(6))
 1068 0476 820F      		add r24,r18
 1069 0478 931F      		adc r25,r19
 1070 047a 2C81      		ldd r18,Y+4
 1071 047c FC01      		movw r30,r24
 1072 047e 2083      		st Z,r18
 238:usart.c       ****                             bytesRecieved++;
 1074               	.LM93:
 1075 0480 8981      		ldd r24,Y+1
 1076 0482 8F5F      		subi r24,lo8(-(1))
 1077 0484 8983      		std Y+1,r24
 1078 0486 00C0      		rjmp .L34
 1079               	.L35:
 241:usart.c       ****                             timeout = 1;
 1081               	.LM94:
 1082 0488 81E0      		ldi r24,lo8(1)
 1083 048a 90E0      		ldi r25,hi8(1)
 1084 048c 9B83      		std Y+3,r25
 1085 048e 8A83      		std Y+2,r24
 1086               	.L34:
 231:usart.c       ****                     while((bytesRecieved < size+1) && (timeout < 50)){  //1 for crc
 1088               	.LM95:
 1089 0490 8981      		ldd r24,Y+1
 1090 0492 282F      		mov r18,r24
 1091 0494 3327      		clr r19
 1092 0496 27FD      		sbrc r18,7
 1093 0498 3095      		com r19
 1094 049a 8D81      		ldd r24,Y+5
 1095 049c 9927      		clr r25
 1096 049e 87FD      		sbrc r24,7
 1097 04a0 9095      		com r25
 1098 04a2 0196      		adiw r24,1
 1099 04a4 2817      		cp r18,r24
 1100 04a6 3907      		cpc r19,r25
 1101 04a8 04F4      		brge .L36
 231:usart.c       ****                     while((bytesRecieved < size+1) && (timeout < 50)){  //1 for crc
 1103               	.LM96:
 1104 04aa 8A81      		ldd r24,Y+2
 1105 04ac 9B81      		ldd r25,Y+3
 1106 04ae 8233      		cpi r24,50
 1107 04b0 9105      		cpc r25,__zero_reg__
 1108 04b2 00F0      		brlo .L37
 1109               	.L36:
 244:usart.c       ****                     if(timeout >= 50){
 1111               	.LM97:
 1112 04b4 8A81      		ldd r24,Y+2
 1113 04b6 9B81      		ldd r25,Y+3
 1114 04b8 8233      		cpi r24,50
 1115 04ba 9105      		cpc r25,__zero_reg__
 1116 04bc 00F4      		brsh .L42
 1117               	.L38:
 247:usart.c       ****                     if(calcChecksum(buffer,size) != buffer[size]){
 1119               	.LM98:
 1120 04be 2D81      		ldd r18,Y+5
 1121 04c0 CE01      		movw r24,r28
 1122 04c2 0696      		adiw r24,6
 1123 04c4 622F      		mov r22,r18
 1124 04c6 0E94 0000 		call calcChecksum
 1125 04ca 482F      		mov r20,r24
 1126 04cc 8D81      		ldd r24,Y+5
 1127 04ce 9927      		clr r25
 1128 04d0 87FD      		sbrc r24,7
 1129 04d2 9095      		com r25
 1130 04d4 9E01      		movw r18,r28
 1131 04d6 2A5F      		subi r18,lo8(-(6))
 1132 04d8 3F4F      		sbci r19,hi8(-(6))
 1133 04da 820F      		add r24,r18
 1134 04dc 931F      		adc r25,r19
 1135 04de FC01      		movw r30,r24
 1136 04e0 8081      		ld r24,Z
 1137 04e2 4817      		cp r20,r24
 1138 04e4 01F0      		breq .L39
 248:usart.c       ****                         sendNACK();
 1140               	.LM99:
 1141 04e6 0E94 0000 		call sendNACK
 249:usart.c       ****                         bytesRecieved = 0;
 1143               	.LM100:
 1144 04ea 1982      		std Y+1,__zero_reg__
 256:usart.c       ****                 }
 1146               	.LM101:
 1147 04ec 0000      		nop
 231:usart.c       ****                     while((bytesRecieved < size+1) && (timeout < 50)){  //1 for crc
 1149               	.LM102:
 1150 04ee 00C0      		rjmp .L34
 1151               	.L39:
 1152               	.LBB3:
 252:usart.c       ****                         sendACK();
 1154               	.LM103:
 1155 04f0 0E94 0000 		call sendACK
 253:usart.c       ****                         memcpy(command.payload,buffer,size);
 1157               	.LM104:
 1158 04f4 8D81      		ldd r24,Y+5
 1159 04f6 282F      		mov r18,r24
 1160 04f8 3327      		clr r19
 1161 04fa 27FD      		sbrc r18,7
 1162 04fc 3095      		com r19
 1163 04fe CE01      		movw r24,r28
 1164 0500 0E96      		adiw r24,14
 1165 0502 0396      		adiw r24,3
 1166 0504 AE01      		movw r20,r28
 1167 0506 4A5F      		subi r20,lo8(-(6))
 1168 0508 5F4F      		sbci r21,hi8(-(6))
 1169 050a BA01      		movw r22,r20
 1170 050c A901      		movw r20,r18
 1171 050e 0E94 0000 		call memcpy
 254:usart.c       ****                         break;
 1173               	.LM105:
 1174 0512 00C0      		rjmp .L33
 1175               	.L42:
 1176               	.LBE3:
 245:usart.c       ****                         break;
 1178               	.LM106:
 1179 0514 0000      		nop
 1180               	.L33:
 258:usart.c       ****             processCommand(&command,&response);
 1182               	.LM107:
 1183 0516 CE01      		movw r24,r28
 1184 0518 0E96      		adiw r24,14
 1185 051a 9E01      		movw r18,r28
 1186 051c 2F5C      		subi r18,lo8(-(49))
 1187 051e 3F4F      		sbci r19,hi8(-(49))
 1188 0520 B901      		movw r22,r18
 1189 0522 0E94 0000 		call processCommand
 259:usart.c       ****             sendResponse(&response);
 1191               	.LM108:
 1192 0526 20E0      		ldi r18,lo8(gs(sendResponse))
 1193 0528 30E0      		ldi r19,hi8(gs(sendResponse))
 1194 052a CE01      		movw r24,r28
 1195 052c C196      		adiw r24,49
 1196 052e F901      		movw r30,r18
 1197 0530 1995      		eicall
 1198               	.LBE2:
 1200               	.LM109:
 1201 0532 00C0      		rjmp .L41
 1212               	.Lscope13:
 1214               		.stabd	78,0,0
 1217               	.global	sendResponse
 1219               	sendResponse:
 1220               		.stabd	46,0,0
 264:usart.c       **** 
 265:usart.c       **** }
 266:usart.c       **** 
 267:usart.c       **** void sendResponse(Response* response){
 1222               	.LM110:
 1223               	.LFBB14:
 1224 0534 DF93      		push r29
 1225 0536 CF93      		push r28
 1226 0538 00D0      		rcall .
 1227 053a 00D0      		rcall .
 1228 053c CDB7      		in r28,__SP_L__
 1229 053e DEB7      		in r29,__SP_H__
 1230               	/* prologue: function */
 1231               	/* frame size = 6 */
 1232               	/* stack size = 8 */
 1233               	.L__stack_usage = 8
 1234 0540 9E83      		std Y+6,r25
 1235 0542 8D83      		std Y+5,r24
 1236 0544 00C0      		rjmp .L46
 1237               	.L48:
 268:usart.c       ****     char checksumBuffer[2];
 269:usart.c       ****     int i;
 270:usart.c       ****     while(1){
 271:usart.c       ****         USART_AddToQueue(response->commandBack);
 272:usart.c       ****         USART_AddToQueue(response->size);
 273:usart.c       ****         checksumBuffer[0] = response->commandBack;
 274:usart.c       ****         checksumBuffer[1] = response->size;
 275:usart.c       ****         USART_AddToQueue(calcChecksum(checksumBuffer,2));
 276:usart.c       ****         if(waitForChecksum() == 0){
 277:usart.c       ****             break;
 278:usart.c       ****         }
 279:usart.c       ****     }
 1239               	.LM111:
 1240 0546 0000      		nop
 1241               	.L46:
 271:usart.c       ****         USART_AddToQueue(response->commandBack);
 1243               	.LM112:
 1244 0548 8D81      		ldd r24,Y+5
 1245 054a 9E81      		ldd r25,Y+6
 1246 054c FC01      		movw r30,r24
 1247 054e 8081      		ld r24,Z
 1248 0550 0E94 0000 		call USART_AddToQueue
 272:usart.c       ****         USART_AddToQueue(response->size);
 1250               	.LM113:
 1251 0554 8D81      		ldd r24,Y+5
 1252 0556 9E81      		ldd r25,Y+6
 1253 0558 FC01      		movw r30,r24
 1254 055a 8181      		ldd r24,Z+1
 1255 055c 0E94 0000 		call USART_AddToQueue
 273:usart.c       ****         checksumBuffer[0] = response->commandBack;
 1257               	.LM114:
 1258 0560 8D81      		ldd r24,Y+5
 1259 0562 9E81      		ldd r25,Y+6
 1260 0564 FC01      		movw r30,r24
 1261 0566 8081      		ld r24,Z
 1262 0568 8B83      		std Y+3,r24
 274:usart.c       ****         checksumBuffer[1] = response->size;
 1264               	.LM115:
 1265 056a 8D81      		ldd r24,Y+5
 1266 056c 9E81      		ldd r25,Y+6
 1267 056e FC01      		movw r30,r24
 1268 0570 8181      		ldd r24,Z+1
 1269 0572 8C83      		std Y+4,r24
 275:usart.c       ****         USART_AddToQueue(calcChecksum(checksumBuffer,2));
 1271               	.LM116:
 1272 0574 CE01      		movw r24,r28
 1273 0576 0396      		adiw r24,3
 1274 0578 62E0      		ldi r22,lo8(2)
 1275 057a 0E94 0000 		call calcChecksum
 1276 057e 0E94 0000 		call USART_AddToQueue
 276:usart.c       ****         if(waitForChecksum() == 0){
 1278               	.LM117:
 1279 0582 0E94 0000 		call waitForChecksum
 1280 0586 8823      		tst r24
 1281 0588 01F4      		brne .L48
 280:usart.c       **** 
 281:usart.c       **** 
 282:usart.c       ****     for(i=0;i<response->size;i++){
 1283               	.LM118:
 1284 058a 1A82      		std Y+2,__zero_reg__
 1285 058c 1982      		std Y+1,__zero_reg__
 1286 058e 00C0      		rjmp .L45
 1287               	.L47:
 283:usart.c       ****         USART_AddToQueue(response->payload[i]);
 1289               	.LM119:
 1290 0590 2D81      		ldd r18,Y+5
 1291 0592 3E81      		ldd r19,Y+6
 1292 0594 8981      		ldd r24,Y+1
 1293 0596 9A81      		ldd r25,Y+2
 1294 0598 820F      		add r24,r18
 1295 059a 931F      		adc r25,r19
 1296 059c 0296      		adiw r24,2
 1297 059e FC01      		movw r30,r24
 1298 05a0 8081      		ld r24,Z
 1299 05a2 0E94 0000 		call USART_AddToQueue
 282:usart.c       ****     for(i=0;i<response->size;i++){
 1301               	.LM120:
 1302 05a6 8981      		ldd r24,Y+1
 1303 05a8 9A81      		ldd r25,Y+2
 1304 05aa 0196      		adiw r24,1
 1305 05ac 9A83      		std Y+2,r25
 1306 05ae 8983      		std Y+1,r24
 1307               	.L45:
 282:usart.c       ****     for(i=0;i<response->size;i++){
 1309               	.LM121:
 1310 05b0 8D81      		ldd r24,Y+5
 1311 05b2 9E81      		ldd r25,Y+6
 1312 05b4 FC01      		movw r30,r24
 1313 05b6 8181      		ldd r24,Z+1
 1314 05b8 282F      		mov r18,r24
 1315 05ba 3327      		clr r19
 1316 05bc 27FD      		sbrc r18,7
 1317 05be 3095      		com r19
 1318 05c0 8981      		ldd r24,Y+1
 1319 05c2 9A81      		ldd r25,Y+2
 1320 05c4 8217      		cp r24,r18
 1321 05c6 9307      		cpc r25,r19
 1322 05c8 04F0      		brlt .L47
 284:usart.c       ****         //USART_AddToQueue(0x30 | (i + 2));
 285:usart.c       ****         //USART_AddToQueue()
 286:usart.c       ****     }
 287:usart.c       ****     USART_AddToQueue(calcChecksum(response->payload,12));
 1324               	.LM122:
 1325 05ca 8D81      		ldd r24,Y+5
 1326 05cc 9E81      		ldd r25,Y+6
 1327 05ce 0296      		adiw r24,2
 1328 05d0 6CE0      		ldi r22,lo8(12)
 1329 05d2 0E94 0000 		call calcChecksum
 1330 05d6 0E94 0000 		call USART_AddToQueue
 1331               	/* epilogue start */
 288:usart.c       **** 
 289:usart.c       **** 
 290:usart.c       **** }
 1333               	.LM123:
 1334 05da 2696      		adiw r28,6
 1335 05dc 0FB6      		in __tmp_reg__,__SREG__
 1336 05de F894      		cli
 1337 05e0 DEBF      		out __SP_H__,r29
 1338 05e2 0FBE      		out __SREG__,__tmp_reg__
 1339 05e4 CDBF      		out __SP_L__,r28
 1340 05e6 CF91      		pop r28
 1341 05e8 DF91      		pop r29
 1342 05ea 0895      		ret
 1348               	.Lscope14:
 1350               		.stabd	78,0,0
 1352               	.global	sendACK
 1354               	sendACK:
 1355               		.stabd	46,0,0
 291:usart.c       **** 
 292:usart.c       **** void sendACK(){
 1357               	.LM124:
 1358               	.LFBB15:
 1359 05ec DF93      		push r29
 1360 05ee CF93      		push r28
 1361 05f0 CDB7      		in r28,__SP_L__
 1362 05f2 DEB7      		in r29,__SP_H__
 1363               	/* prologue: function */
 1364               	/* frame size = 0 */
 1365               	/* stack size = 2 */
 1366               	.L__stack_usage = 2
 293:usart.c       ****     USART_AddToQueue(128);
 1368               	.LM125:
 1369 05f4 80E8      		ldi r24,lo8(-128)
 1370 05f6 0E94 0000 		call USART_AddToQueue
 1371               	/* epilogue start */
 294:usart.c       **** }
 1373               	.LM126:
 1374 05fa CF91      		pop r28
 1375 05fc DF91      		pop r29
 1376 05fe 0895      		ret
 1378               	.Lscope15:
 1380               		.stabd	78,0,0
 1382               	.global	sendNACK
 1384               	sendNACK:
 1385               		.stabd	46,0,0
 295:usart.c       **** 
 296:usart.c       **** void sendNACK(){
 1387               	.LM127:
 1388               	.LFBB16:
 1389 0600 DF93      		push r29
 1390 0602 CF93      		push r28
 1391 0604 CDB7      		in r28,__SP_L__
 1392 0606 DEB7      		in r29,__SP_H__
 1393               	/* prologue: function */
 1394               	/* frame size = 0 */
 1395               	/* stack size = 2 */
 1396               	.L__stack_usage = 2
 297:usart.c       ****     USART_AddToQueue(0);
 1398               	.LM128:
 1399 0608 80E0      		ldi r24,lo8(0)
 1400 060a 0E94 0000 		call USART_AddToQueue
 1401               	/* epilogue start */
 298:usart.c       **** }
 1403               	.LM129:
 1404 060e CF91      		pop r28
 1405 0610 DF91      		pop r29
 1406 0612 0895      		ret
 1408               	.Lscope16:
 1410               		.stabd	78,0,0
 1412               	.global	waitForChecksum
 1414               	waitForChecksum:
 1415               		.stabd	46,0,0
 299:usart.c       **** 
 300:usart.c       **** char waitForChecksum(){
 1417               	.LM130:
 1418               	.LFBB17:
 1419 0614 DF93      		push r29
 1420 0616 CF93      		push r28
 1421 0618 CDB7      		in r28,__SP_L__
 1422 061a DEB7      		in r29,__SP_H__
 1423               	/* prologue: function */
 1424               	/* frame size = 0 */
 1425               	/* stack size = 2 */
 1426               	.L__stack_usage = 2
 301:usart.c       ****     while(1){
 302:usart.c       ****         //if(UCSR1A & (1<<RXC1)){
 303:usart.c       ****             if(USART_GetChar() == 0xFF){
 1428               	.LM131:
 1429 061c 0E94 0000 		call USART_GetChar
 1430 0620 8F3F      		cpi r24,lo8(-1)
 1431 0622 01F4      		brne .L52
 304:usart.c       ****             //if(UDR1 = 0xFF) {
 305:usart.c       **** 
 306:usart.c       ****                 return 0;
 1433               	.LM132:
 1434 0624 80E0      		ldi r24,lo8(0)
 1435 0626 00C0      		rjmp .L53
 1436               	.L52:
 307:usart.c       ****             } else {
 308:usart.c       ****                 return -1;
 1438               	.LM133:
 1439 0628 8FEF      		ldi r24,lo8(-1)
 1440               	.L53:
 1441               	/* epilogue start */
 309:usart.c       ****             }
 310:usart.c       **** 
 311:usart.c       ****         //} else {
 312:usart.c       ****         //    vTaskDelay(1);
 313:usart.c       ****         //}
 314:usart.c       **** 
 315:usart.c       ****     }
 316:usart.c       **** }
 1443               	.LM134:
 1444 062a CF91      		pop r28
 1445 062c DF91      		pop r29
 1446 062e 0895      		ret
 1448               	.Lscope17:
 1450               		.stabd	78,0,0
 1454               	.global	calcChecksum
 1456               	calcChecksum:
 1457               		.stabd	46,0,0
 317:usart.c       **** 
 318:usart.c       **** uint8_t calcChecksum(uint8_t* buffer,uint8_t size){
 1459               	.LM135:
 1460               	.LFBB18:
 1461 0630 DF93      		push r29
 1462 0632 CF93      		push r28
 1463 0634 00D0      		rcall .
 1464 0636 00D0      		rcall .
 1465 0638 CDB7      		in r28,__SP_L__
 1466 063a DEB7      		in r29,__SP_H__
 1467               	/* prologue: function */
 1468               	/* frame size = 6 */
 1469               	/* stack size = 8 */
 1470               	.L__stack_usage = 8
 1471 063c 9D83      		std Y+5,r25
 1472 063e 8C83      		std Y+4,r24
 1473 0640 6E83      		std Y+6,r22
 319:usart.c       ****     uint8_t checksum = 0;
 1475               	.LM136:
 1476 0642 1982      		std Y+1,__zero_reg__
 1477               	.LBB4:
 320:usart.c       ****     for(int i = 0; i < size; i++) {
 1479               	.LM137:
 1480 0644 1B82      		std Y+3,__zero_reg__
 1481 0646 1A82      		std Y+2,__zero_reg__
 1482 0648 00C0      		rjmp .L55
 1483               	.L56:
 321:usart.c       ****         checksum += *(buffer++);
 1485               	.LM138:
 1486 064a 8C81      		ldd r24,Y+4
 1487 064c 9D81      		ldd r25,Y+5
 1488 064e FC01      		movw r30,r24
 1489 0650 8081      		ld r24,Z
 1490 0652 9981      		ldd r25,Y+1
 1491 0654 890F      		add r24,r25
 1492 0656 8983      		std Y+1,r24
 1493 0658 8C81      		ldd r24,Y+4
 1494 065a 9D81      		ldd r25,Y+5
 1495 065c 0196      		adiw r24,1
 1496 065e 9D83      		std Y+5,r25
 1497 0660 8C83      		std Y+4,r24
 320:usart.c       ****     for(int i = 0; i < size; i++) {
 1499               	.LM139:
 1500 0662 8A81      		ldd r24,Y+2
 1501 0664 9B81      		ldd r25,Y+3
 1502 0666 0196      		adiw r24,1
 1503 0668 9B83      		std Y+3,r25
 1504 066a 8A83      		std Y+2,r24
 1505               	.L55:
 320:usart.c       ****     for(int i = 0; i < size; i++) {
 1507               	.LM140:
 1508 066c 8E81      		ldd r24,Y+6
 1509 066e 282F      		mov r18,r24
 1510 0670 30E0      		ldi r19,lo8(0)
 1511 0672 8A81      		ldd r24,Y+2
 1512 0674 9B81      		ldd r25,Y+3
 1513 0676 8217      		cp r24,r18
 1514 0678 9307      		cpc r25,r19
 1515 067a 04F0      		brlt .L56
 1516               	.LBE4:
 322:usart.c       ****     }
 323:usart.c       ****     return checksum;
 1518               	.LM141:
 1519 067c 8981      		ldd r24,Y+1
 1520               	/* epilogue start */
 324:usart.c       **** }
 1522               	.LM142:
 1523 067e 2696      		adiw r28,6
 1524 0680 0FB6      		in __tmp_reg__,__SREG__
 1525 0682 F894      		cli
 1526 0684 DEBF      		out __SP_H__,r29
 1527 0686 0FBE      		out __SREG__,__tmp_reg__
 1528 0688 CDBF      		out __SP_L__,r28
 1529 068a CF91      		pop r28
 1530 068c DF91      		pop r29
 1531 068e 0895      		ret
 1539               	.Lscope18:
 1541               		.stabd	78,0,0
 1546               	.Letext0:
 1547               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 usart.c
     /tmp/ccu8Ra6i.s:2      *ABS*:0000003f __SREG__
     /tmp/ccu8Ra6i.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccu8Ra6i.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccu8Ra6i.s:5      *ABS*:00000034 __CCP__
     /tmp/ccu8Ra6i.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccu8Ra6i.s:7      *ABS*:00000001 __zero_reg__
                            *COM*:00000002 USART_WriteQueue
                            *COM*:00000002 USART_ReadQueue
                            *COM*:00000002 USART_WriteQueueLog
     /tmp/ccu8Ra6i.s:114    .text:00000000 USART_Init
     /tmp/ccu8Ra6i.s:255    .text:000000da USART_Write
     /tmp/ccu8Ra6i.s:308    .text:0000010e USART_Write_Unprotected
     /tmp/ccu8Ra6i.s:360    .text:00000142 USART_Read
     /tmp/ccu8Ra6i.s:404    .text:00000166 __vector_36
     /tmp/ccu8Ra6i.s:492    .text:000001ea USART_AddToQueue
     /tmp/ccu8Ra6i.s:534    .text:00000218 USART_TransmitString
     /tmp/ccu8Ra6i.s:594    .text:00000256 vTaskUSARTWrite
     /tmp/ccu8Ra6i.s:660    .text:000002a0 USART_LogChar
     /tmp/ccu8Ra6i.s:702    .text:000002ce USART_LogString
     /tmp/ccu8Ra6i.s:762    .text:0000030c vTaskUSARTLog
     /tmp/ccu8Ra6i.s:827    .text:00000356 USART_GetChar
     /tmp/ccu8Ra6i.s:882    .text:0000038c vTaskUSARTRead
     /tmp/ccu8Ra6i.s:1456   .text:00000630 calcChecksum
     /tmp/ccu8Ra6i.s:1384   .text:00000600 sendNACK
     /tmp/ccu8Ra6i.s:1354   .text:000005ec sendACK
     /tmp/ccu8Ra6i.s:1219   .text:00000534 sendResponse
     /tmp/ccu8Ra6i.s:1414   .text:00000614 waitForChecksum

UNDEFINED SYMBOLS
xQueueGenericCreate
__udivmodsi4
xQueueGenericSendFromISR
xQueueGenericSend
xQueueGenericReceive
memcpy
processCommand
__do_clear_bss
